<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>タイトルコール当てクイズ</title>
<style type="text/css">

/* Fukol https://github.com/Heydon/fukol-grids */
.fukol-grid{display:flex;flex-wrap:wrap;margin:-.5em;}
.fukol-grid>*{flex:1 0 5em;margin:.5em;}
/* 属性色設定 */
.imascg-cute{color:#e26; background-color:#fdd}
.imascg-cool{color:#06f; background-color:#eef}
.imascg-passion{color:#c80; background-color:#feb}

</style>
</head>
<body>
<script>

"use strict";
const NEW_TAG = (tag) => document.createElement(tag);
const GET_ID = (id) => document.getElementById(id);

// AudioContext初期化 by Mozilla
const gAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Webkit/blink系ブラウザは接頭辞が必要、Safariは「window.」をつけないと動かない
const gURL = window.URL || window.webkitURL; //URLも同様らしいのでそうしておく

const hostStarlightDB = "https://starlight.kirara.ca/";
const pathCharList = "/api/v1/list/char_t?keys=chara_id";
const pathCharDetail = "/api/v1/char_t/";
//URLインターフェースを利用して引数を安全にURL化(さもなくば例外を投げる)
const urlFirstRequest = new gURL(pathCharList,hostStarlightDB);
const urlVirtualRequest = new gURL( pathCharDetail, hostStarlightDB );

let arIdoldatas = [];
let divLog = null;

class tIdol {
	constructor( _argobj ){
		this.cid = _argobj["chara_id"]; //ID
		this.name = _argobj["name"];    //名前
		this.type = _argobj["type"];    //属性
		this.voice = _argobj["voice"];  //担当声優

		//初期化中にのみ使うもの
		const id2vo = ch => `/va2/${ (this.cid ^ 0x1042fc).toString(16) }10442${ch}16ab.mp3`;
		const urlIcon = new gURL( _argobj["icon_image_ref"], urlVirtualRequest ).href;
		const urlTitle1 = new gURL( id2vo("c"), urlIcon ).href;
		//本家ソースちら見した限り、音声は画像と同じサーバにあるらしい。

		//アイドル個人の情報のvoiceが空文字列ではない＝タイトルコールがある「かもしれない」。
		//例えば2017年の「恋が咲く季節」イベントの時(だと思われる)、この曲を歌うアイドルのCV 5名分 が反映されたものの、
		//タイトルコール実装はカード報酬となった2名にとどまっている。
		//タイトルコールが存在するかは個人情報JSONに現れないので直接音声ファイルのURLを叩いてみる。

		// H TML I mage E lement の略
		this.HIEicon = NEW_TAG("img");
		this.HIEicon.owner = this; //このクラス自体にアクセスできるように
		this.HIEicon.alt = this.name + ( this.voice ? `(cv. ${this.voice})` : "" );
		this.HIEicon.onload = this.onOkayCallback;
		this.HIEicon.onerror = this.onErrorCallback;
		this.HIEicon.src = urlIcon;

		// H TML A udio E lement の略
		this.HAEtitle1 = NEW_TAG("audio");
		this.HAEtitle1.owner = this;
		this.HAEtitle1.oncanplaythrough = this.onOkayCallback; //最後まで再生できる状態になった
		this.HAEtitle1.onerror = this.onErrorCallback;
		this.HAEtitle1.src = urlTitle1;
	}

	//リソース系共通・読み込み成功時コールバック：thisはイベント対象となったHTMLElement
	onOkayCallback(){ this.owner.postResult( this, true ); }
	//リソース系共通・読み込み失敗時コールバック：thisはイベント対象となったHTMLElement
	onErrorCallback(){ this.owner.postResult( this, false ); }
	//リソース系共通・読み込み結果処理コールバック
	postResult( _elmTgt, _bSuccess ){
		console.log(`[${_bSuccess?"OK":"NG"}] ${this.name} <- ${_elmTgt.src}`);
		//コールバックをクリアする
		if( _elmTgt.onload ){ _elmTgt.onload = null; }
		if( _elmTgt.onerror ){ _elmTgt.onerror = null; }
		if( _elmTgt.oncanplaythrough ){ _elmTgt.oncanplaythrough = null; }
	}

	get isIconReady(){ return this.HIEicon.naturalHeight > 0; }
	get isAudioReady(){ return this.HAEtitle1.readyState === HTMLMediaElement.HAVE_ENOUGH_DATA; }

/*
	playVoice( _dest, _timing ){
		if( ! this.bufvoice ) return false;

		let bfsrc = gAudioCtx.createBufferSource();
		bfsrc.buffer = this.bufvoice;
		bfsrc.connect( _dest );
		bfsrc.start( _timing );

		return true;
	}
	//ボタンを押すとタイトルコール
	onIconButton(){
		this.owner.playVoice( gAudioCtx.destination, gAudioCtx.currentTime );
	}
*/
}

// ++非同期関数++ 問い合わせてレスポンスのJSONをオブジェクトに変換して返す。次の関数でのみ使う
async function asyncFetchAndStrip( url ) {
	const resReq = await fetch( url.href );
	return (await resReq.json())["result"];
}

// ++非同期関数++ リソースの読み出し
async function asyncFetchResources() {
	let arrslt = await asyncFetchAndStrip(urlFirstRequest);
	//最初の結果を利用して次に呼び出すURLを構築
	let strCharIds = "";
	for( const s of arrslt ){ strCharIds += (strCharIds.length>0 ? `,${s["chara_id"]}` : s["chara_id"]); }
	let secondRequestURL = new gURL(pathCharDetail+strCharIds, urlFirstRequest);
	arrslt = await asyncFetchAndStrip(secondRequestURL);

	const elmfukol = NEW_TAG("div");
	elmfukol.className = "fukol-grid";
	divLog.appendChild(elmfukol);

	//大量のfetchを発して相手サーバに負荷をかけるのも悪いので、わざと一つずつfetchしている。
	let cnt = 0;
	for( let idx = 0 ; idx < arrslt.length ; idx++  ){
		let objrslt = arrslt[idx];

		if( ! objrslt["voice"] ) continue;
		//先に音声の所在を確認し、成功したら画像を取り寄せる、の順。
		//URLを相対から絶対に変換しておく
/*		const id2vo = id => "/va2/"+(id ^ 0x1042fc).toString(16)+"10442d16ab.mp3";
mov		const urlic = new gURL( objrslt["icon_image_ref"], secondRequestURL ).href;
-ed		const urlvo = new gURL( id2vo( objrslt["chara_id"] ), urlic ).href; //音声は画像と同じサーバにあるらしい。本家ソースちら見した限り。
*/		//即fetchしてステータスを見る
//		let resvo = await fetch(urlvo).catch( e=>{console.log("動作には支障ありません。");} ); //fetchのerrorは(try-catchと同様)、prms.catchでまるっと処理してしまえる
//		if( resvo && resvo.status === 200 ){
			//音声があった！
//			const resic = await fetch(urlic);
//			if( resic.status === 200 ){ //画像もOK
				//新しいobjを作ってグローバル配列に追加
				let objIdol = new tIdol(objrslt);
				arIdoldatas.push(objIdol);
				//グリッドシステムに表示ブロックを入れ込む。
				let p = NEW_TAG("div");
				p.className = "imascg-"+objIdol.type;
				p.appendChild( objIdol.HIEicon );
				p.appendChild( NEW_TAG("br") );
				p.appendChild( objIdol.HAEtitle1 );
				objIdol.HAEtitle1.controls = true;
				p.appendChild( NEW_TAG("br") );
				let q = NEW_TAG("span");
				q.textContent = `#${++cnt}-${idx}/${arrslt.length}[${objIdol.cid}]`;
				p.appendChild( q );
				elmfukol.insertBefore(p, elmfukol.firstChild);
//			}
//		}
	}
	let p = NEW_TAG("p");
	p.textContent = `読み取り完了。全 ${arrslt.length} 人中ボイス設定ありは ${cnt} 人でした。`;
	divLog.insertBefore(p, divLog.firstChild);
}

//ページ読み込み時処理
window.addEventListener("load",()=>{
	divLog = NEW_TAG("div");
	document.body.appendChild(divLog);
	asyncFetchResources();
});

</script>
</body>
</html>

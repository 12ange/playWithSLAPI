<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>タイトルコール当てクイズ</title>
<style type="text/css">

/* Fukol https://github.com/Heydon/fukol-grids */
.fukol-grid{display:flex;flex-wrap:wrap;margin:-.5em;}
.fukol-grid>*{flex:1 0 5em;margin:.5em;}
/* 属性色設定 */
.imascg-cute{color:#e26; background-color:#fdd}
.imascg-cool{color:#06f; background-color:#eef}
.imascg-passion{color:#c80; background-color:#feb}

</style>
</head>
<body>
<script>

"use strict";
const NEW_TAG = (tag) => document.createElement(tag);
const GET_ID = (id) => document.getElementById(id);

// AudioContext初期化 by Mozilla
const gAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Webkit/blink系ブラウザは接頭辞が必要、Safariは「window.」をつけないと動かない
const gURL = window.URL || window.webkitURL; //URLも同様らしいのでそうしておく

const hostStarlightDB = "https://starlight.kirara.ca/";
const pathCharList = "/api/v1/list/char_t?keys=chara_id";
const pathCharDetail = "/api/v1/char_t/";
//URLインターフェースを利用して引数を安全にURL化(さもなくば例外を投げる)
const urlFirstRequest = new gURL(pathCharList,hostStarlightDB);
const urlVirtualRequest = new gURL( pathCharDetail, hostStarlightDB );

let arIdoldatas = [];
let divLog = null;

class tIdol {
	//クラス用定数
	static get pNmADtitle1(){ return "ADtitle1"; }

	//**コンストラクタ**
	constructor( _argobj ){
		this.cid = _argobj["chara_id"]; //ID
		this.name = _argobj["name"];    //名前
		this.type = _argobj["type"];    //属性
		this.voice = _argobj["voice"];  //担当声優

		//初期化中にのみ使うもの
		const id2vo = ch => `/va2/${ (this.cid ^ 0x1042fc).toString(16) }10442${ch}16ab.mp3`;
		const urlIcon = new gURL( _argobj["icon_image_ref"], urlVirtualRequest ).href;
		const urlTitle1 = new gURL( id2vo("c"), urlIcon ).href;
		//本家ソースちら見した限り、音声は画像と同じサーバにあるらしい。

		//アイドル個人の情報のvoiceが空文字列ではない＝タイトルコールがある「かもしれない」。
		//例えば2017年の「恋が咲く季節」イベントの時(だと思われる)、この曲を歌うアイドルのCV 5名分 が反映されたものの、
		//タイトルコール実装はカード報酬となった2名にとどまっている。
		//タイトルコールが存在するかは個人情報JSONに現れないので直接音声ファイルのURLを叩いてみる。

		// H TML I mage E lement の略
		this.HIEicon = NEW_TAG("img");
		this.HIEicon.alt = this.name + ( this.voice ? `(cv. ${this.voice})` : "" );
		this.HIEicon.src = urlIcon;

		// 音声データを(非同期で)読み込む
		this.fetchAudioData( this.constructor.pNmADtitle1, urlTitle1 );
	}

	//音源取得(非同期：内部でPromiseチェーンしている)
	fetchAudioData( _propName, _href ){
		this[_propName] = undefined;

		fetch( _href
		).then( r => r.arrayBuffer()
		).then( ab => gAudioCtx.decodeAudioData(ab)
		).then( ad => { this[_propName] = ad ; }
		).catch( e => { this[_propName] = null;} );
	}

	//アイコン準備状態(読み取り専用プロパティ)
	get isIconReady(){ return this.HIEicon.naturalHeight > 0; }
	//音声準備状態(読み取り専用プロパティ)
	get isAudioReady(){ return !! this[ this.constructor.pNmADtitle1 ]; }
	//音声再生
	playAudio( _dest, _timing ){
		if( ! this.isAudioReady ) return false;

		let bfsrc = gAudioCtx.createBufferSource();
		bfsrc.buffer = this[ this.constructor.pNmADtitle1 ];
		bfsrc.connect( _dest );
		bfsrc.start( _timing );
		return true;
	}
}

// ++非同期関数++ 問い合わせてレスポンスのJSONをオブジェクトに変換して返す。次の関数でのみ使う
async function asyncFetchAndStrip( url ) {
	const resReq = await fetch( url.href );
	return (await resReq.json())["result"];
}

// ++非同期関数++ リソースの読み出し
async function asyncFetchResources() {
	let arrslt = await asyncFetchAndStrip(urlFirstRequest);
	//最初の結果を利用して次に呼び出すURLを構築
	let strCharIds = "";
	for( const s of arrslt ){ strCharIds += (strCharIds.length>0 ? `,${s["chara_id"]}` : s["chara_id"]); }
	let secondRequestURL = new gURL(pathCharDetail+strCharIds, urlFirstRequest);
	arrslt = await asyncFetchAndStrip(secondRequestURL);

	const elmfukol = NEW_TAG("div");
	elmfukol.className = "fukol-grid";
	divLog.appendChild(elmfukol);

	//大量のfetchを発して相手サーバに負荷をかけるのも悪いので、わざと一つずつfetchしている。
	let cnt = 0;
	for( let idx = 0 ; idx < arrslt.length ; idx++  ){
		let objrslt = arrslt[idx];
		if( ! objrslt["voice"] ) continue;

		//新しいobjを作ってグローバル配列に追加
		let objIdol = new tIdol(objrslt);
		arIdoldatas.push(objIdol);
		//グリッドシステムに表示ブロックを入れ込む。
		let p = NEW_TAG("div");
		p.className = "imascg-"+objIdol.type;
		p.appendChild( objIdol.HIEicon );
		p.appendChild( NEW_TAG("br") );

		let b = NEW_TAG("button");
		b.textContent = tIdol.pNmADtitle1;
		b.onclick = ()=>{ objIdol.playAudio( gAudioCtx.destination, gAudioCtx.currentTime ); };
		p.appendChild( b );
		p.appendChild( NEW_TAG("br") );

		let q = NEW_TAG("span");
		q.textContent = `#${++cnt}-${idx}/${arrslt.length}[${objIdol.cid}]`;
		p.appendChild( q );
		elmfukol.insertBefore(p, elmfukol.firstChild);
	}
	let p = NEW_TAG("p");
	p.textContent = `読み取り完了。全 ${arrslt.length} 人中ボイス設定ありは ${cnt} 人でした。`;
	divLog.insertBefore(p, divLog.firstChild);
}

//ページ読み込み時処理
window.addEventListener("load",()=>{
	divLog = NEW_TAG("div");
	document.body.appendChild(divLog);
	asyncFetchResources();
});

</script>
</body>
</html>

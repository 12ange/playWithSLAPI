<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<title>デレステタイトルコール遊び場</title>
<script async src="./idb.js"></script>
<script async src="./cachey.js"></script>
<link rel="stylesheet" type="text/css" href="../imasCGg4u/imascgss.css">
<style>

/* 共通設定 */
body{text-align:center}
h1{margin:.5em 0;font-size: 5.75vw}
/* ボタンの表示内容を有効無効で変えるための仕込み */
button:not(:disabled)>.show-disabled,
button:disabled>.hide-disabled{display:none}
/* アイドル選択部 */
#idol-choice{display:inline-flex;flex-wrap:wrap;max-height:50vh;overflow-y:scroll}
label{cursor:pointer;margin:4px 3px;padding:0 4px}
input[type="checkbox"]{display:none}
input[type="checkbox"]:checked+img{opacity:1}
input[type="checkbox"]:not(checked)+img{opacity:.3}
/*その他、実験用*/
#div-log{color:silver}
#div-input{border:1px dashed green;margin:.3em;padding:.2em}
#div-output{border:1px dotted cyan;margin:.3em;padding:.2em}

</style></head><body>

<template id="screen-top">
	<h1>デレステタイトルコール遊び場</h1><!-- document.titleに反映する -->
	<div id="div-log"></div>
	<div id="div-output"></div>
	<div id="div-input">
		<button id="gotoQuiz" class="imascgss" disabled>クイズ</button>
		<button id="gotoListen" class="imascgss" disabled>試聴室</button>
	</div>
</template>

<template id="screen-museum">
	<h1>デレステタイトルコール試聴室</h1>
</template>

<template id="screen-quiz">
	<h1>デレステタイトルコール当てクイズ</h1>
	<div id="div-output">
		<span id="HSEresult"></span><br>
		<span id="HSEquiz"></span><br>
		<button class="imascgss" id="HBEplay">
			<span class="hide-disabled">Play</span>
			<span class="show-disabled">&gt;&gt;&gt;&gt;</span>
		</button>
	</div>
	<div id="idol-choice"></div>
	<div id="div-input">
		<span id="HSEanswer"></span><br>
		<button class="imascgss" id="HBEanswer">
			<span class="hide-disabled">Answer</span>
			<span class="show-disabled">------</span>
		</button>
	</div>
</template>

<template id="icon-idol">
	<label>
		<input type="checkbox">
		<img alt="NIL" width="50" height="50">
	</label>
</template>

<script>
"use strict";

// AudioContext初期化 by Mozilla
const gAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Webkit/blink系ブラウザは接頭辞が必要、Safariは「window.」をつけないと動かない
const gURL = window.URL || window.webkitURL; //URLも同様らしいのでそうしておく

const hostStarlightDB = "https://starlight.kirara.ca/";
const pathCharList = "/api/v1/list/card_t?keys=chara_id"; //※char_tが500を返すのでcard_tで代用
const pathCharDetail = "/api/v1/char_t/";
//URLインターフェースを利用して引数を安全にURL化(さもなくば例外を投げる)
const urlFirstRequest = new gURL(pathCharList,hostStarlightDB);
const urlVirtualRequest = new gURL( pathCharDetail, hostStarlightDB );

//コンプレッサー作成とAudioContextへ接続
const gAudioCompNode = (c=>{
	let n = c.createDynamicsCompressor();
	n.connect(c.destination);
	return n;
})(gAudioCtx);

let arIdolDatas = [];
let arIdolLoaders = [];

class tIdol {
	//クラス用定数
	static get pNmIMGicon(){ return "IMGicon"; }
	static get pNmADtitleS(){ return "ADtitleS"; } //タイトルコール/ソロ用
	static get pNmADtitleU(){ return "ADtitleU"; } //タイトルコール/ユニット用
	static get pNmADnameD(){ return "ADnameD"; }   //名前＋です
	static get pNmADnameX(){ return "ADnameX"; }   //名前(体言止め)

	//**コンストラクタ**
	constructor( _argobj ){
		//同一名称プロパティをコピーしまくりんぐ
		const copyProprts = a=>{ for(const n of a){ this[n] = _argobj[n]; } };
		copyProprts( [
			"cid","name","type","voice", this.constructor.pNmIMGicon,
			this.constructor.pNmADtitleS, this.constructor.pNmADtitleU, this.constructor.pNmADnameD, this.constructor.pNmADnameX
		] );
		this[ this.constructor.pNmIMGicon ].alt = `${this.name} (cv. ${this.voice})`;
	}

	//プロパティ名を指定して音声再生
	playAudio(
		_pName = this.constructor.pNmADtitleS,
		_dest = gAudioCtx.destination,
		_timing = gAudioCtx.currentTime
	){
		let bfsrc = gAudioCtx.createBufferSource();
		bfsrc.buffer = this[_pName];
		bfsrc.connect(_dest);
		bfsrc.start(_timing);
		return true;
	}

	//プロパティ名を指定して音声長[秒]を取得
	getDurationOf(_pName){
		const tgtpnm = "duration";
		return ( _pName in this && tgtpnm in this[_pName] )? this[_pName][tgtpnm] : 0;
	}
}

class tIdolLoader {

	//**コンストラクタ**
	constructor( _argobj ){
		//必要な情報を抜き取る(含・tIdol生成時にのみ必要なもの)
		this.cid = _argobj["chara_id"]; //ID
		this.name = _argobj["name"];    //名前
		this.type = _argobj["type"];    //属性
		this.voice = _argobj["voice"];  //担当声優
		//アイコン画像のURLは絶対参照に変換して保存
		this.urlIcon = new gURL( _argobj["icon_image_ref"], urlVirtualRequest ).href;
	}

	//非同期読み込み開始
	async asyncLoad( _fnFinally ){
		// ++非同期関数++ URLから音声データにする
		const asyncGetAudioData = async ( _href )=>{
			let aud;
			try {
				const abf = await cachey.requestOrFetch(_href);
				aud = await gAudioCtx.decodeAudioData(abf);
			} catch (e) {
				aud = null;
			}
			return aud;
		};
		// ++非同期関数++
		const promiseGetImage = ( _href )=>{
			return new Promise( (resolve,reject)=>{
				let hie = document.createElement("img");
				hie.onload = ()=>{ resolve(hie); };
				hie.onerror = (e)=>{ reject(e); };
				hie.src = _href;
			} );
		};
		// ++非同期関数++ URLを与えてIMGタグにする
		const asyncGetImageElement = async ( _href )=>{
			let hie;
			try {
				const blb = await cachey.requestOrFetch(_href);
				hie = await promiseGetImage( gURL.createObjectURL( blb ) );
			} catch (e) {
				hie = null;
			}
			return hie;
		};

		//アイドル個人の情報のvoiceが空文字列ではない＝タイトルコールがある「かもしれない」。
		//例えば2017年の「恋が咲く季節」イベントの時(だと思われる)、この曲を歌うアイドルのCV 5名分 が反映されたものの、
		//タイトルコール実装はカード報酬となった2名にとどまっている。
		//タイトルコールが存在するかは個人情報JSONに現れないので直接音声ファイルのURLを叩いてみる。
		const id2vo = c => `/va2/${ (this.cid ^ 0x1042fc).toString(16) }10442${c}16ab.mp3`;
		//本家ソースちら見した限り、音声は画像と同じサーバにあるらしい。
		const urlTitleS = new gURL( id2vo("c"), this.urlIcon ).href; //タイトルコール/ソロ用
		const urlTitleU = new gURL( id2vo("d"), this.urlIcon ).href; //タイトルコール/ユニット用
		const urlNameD = new gURL( id2vo("2"), this.urlIcon ).href;  //名前＋です
		const urlNameX = new gURL( id2vo("1"), this.urlIcon ).href;  //名前(体言止め)

		try {
			this[tIdol.pNmADtitleS] = await asyncGetAudioData(urlTitleS);
			if( ! this[tIdol.pNmADtitleS] ){ throw "if there is HTTP:404 then never mind."; }
			//引き続き、残る要素を読み込む。並列処理テクを使う。
			//1. await抜きでasync関数を呼び出すことでPromiseを生成(実行開始)。
			const prmIcon = asyncGetImageElement(this.urlIcon);
			const prmTitleU = asyncGetAudioData(urlTitleU);
			const prmNameD = asyncGetAudioData(urlNameD);
			const prmNameX = asyncGetAudioData(urlNameX);
			//2. そのPromiseインスタンスをawaitする。Promise群の中で一番遅いものの時間で処理できる。
			this[tIdol.pNmIMGicon] = await prmIcon;
			this[tIdol.pNmADtitleU] = await prmTitleU;
			this[tIdol.pNmADnameD] = await prmNameD;
			this[tIdol.pNmADnameX] = await prmNameX;
		} catch (e) {
			//読み込めなかったらこのブロックに来てからfinallyブロックへ
			//404以外に、CDN由来の52x,530エラーがある。
			//対応的には、4xx:再挑戦不可 52[02457]:自動再挑戦可能 52[136]|530:今は諦める(手動再挑戦)
			console.warn(e);
			console.warn(`cause of [${this.cid}] ${this.name} (cv. ${this.voice})`);
		} finally {
			_fnFinally( this );
		}
	}

	//class tIdol のインスタンスを取り出す。さもなくば return null
	standIdol(){
		return (
			this[tIdol.pNmIMGicon] && this[tIdol.pNmADtitleS] && this[tIdol.pNmADtitleU] && this[tIdol.pNmADnameD] && this[tIdol.pNmADnameX]
		)? new tIdol(this) : null;
	}
}

// ++非同期関数++ リソースの読み出し
async function asyncFetchResources() {

	// ++非同期関数++ 問い合わせてレスポンスのJSONをオブジェクトに変換して返す。
	const asyncFetchAndStrip = async ( url ) => {
		const resReq = await fetch( url.href );
		return (await resReq.json())["result"];
	};

	let prmInitIDB = cachey.asyncInit(); //cacheyの初期化Promise

	let arrslt = await asyncFetchAndStrip(urlFirstRequest);
	//最初の結果を利用して次に呼び出すURLを構築
	let setCharId = new Set();
	arrslt.forEach( o=>{setCharId.add(o["chara_id"])} );
	let strCharIds = Array.from(setCharId).join();
	let secondRequestURL = new gURL(pathCharDetail+strCharIds, urlFirstRequest);
	arrslt = await asyncFetchAndStrip(secondRequestURL);
	await prmInitIDB; //cacheyの初期化完了もここで待つ
	//console.log( `cachey:${cachey.dbOpened?"READY":("ERROR/"+cachey.strDbErr)}` );

	for( let objrslt of arrslt ){
		if( ! objrslt["voice"] ) continue;
		//専用のローダーに返答オブジェクトを渡せば良いようにしてあります
		let idldr = new tIdolLoader(objrslt);
		arIdolLoaders.push( idldr );
		idldr.asyncLoad( cbIdolLoader );
	}
	console.log(`(asyncFetchResources) 全 ${arrslt.length} 人、CV設定あり ${arIdolLoaders.length} 人`);
}

//callback of tIdolLoaer
function cbIdolLoader( _objILr ){

	//インスタンスを取り出せれば配列に登録。
	let objIdol = _objILr.standIdol();
	if( objIdol instanceof tIdol ){ arIdolDatas.push( objIdol ); }

	//処理が終わったので、配列から取り除く
	const idxILs = arIdolLoaders.indexOf( _objILr );
	if( idxILs < 0 ) throw new Error("cbIdolLoader() / unknown tIdolLoader object found");
	arIdolLoaders.splice( idxILs, 1 );

	//状態更新(反映)処理を呼ぶ
	//console.log(`(cbIdolLoader) 結果=${!!objIdol} 成功x${arIdolDatas.length} 残件x${arIdolLoaders.length}`);
	progressFetch();
	if( arIdolLoaders.length == 0 ){ afterFetch(); }
}

//<template id="引数">のクローンを得る
function getCloneOfTemplateById(id){
	const tem = document.querySelector(`template#${id}`);
	if(tem instanceof HTMLTemplateElement){
		const cln = tem.content.cloneNode(true)
		if(cln instanceof DocumentFragment){
			return cln
		}else{
			throw new Error(`cloning made wrong with template#${id}.`)
		}
	}else{
		throw new Error(`template#${id} is not found.`)
	}
}

//リソース読み出し前処理
function preFetch(){
	const clone = getCloneOfTemplateById("screen-top")

	let h = clone.querySelector("h1");
	document.title = h?.textContent ?? document.title;
	let d = clone.querySelector("#div-log");
	if(d){
		d.textContent = `⌛リソース取得開始${window.indexedDB ? "" : " !! NO-INDEXED-DATABASE"}`;
	}

	document.body.appendChild(clone);
	asyncFetchResources();
}

//リソース読み出し中処理
function progressFetch(){
	let d = document.querySelector("#div-log");
	if(d){
		d.textContent = `⌛リソース取得中... ${ 100 * arIdolDatas.length / (arIdolDatas.length+arIdolLoaders.length) |0 }%`;
	}
}

//リソース読み出し後処理
function afterFetch(){
	//CuCoPa順＞ID順・昇順に整列。リソース読み出し完了は順不同になるため。
	arIdolDatas.sort( (fore,back)=>{
		const typeIndex = ["cute","cool","passion"];
		let diffType = typeIndex.indexOf(fore.type) - typeIndex.indexOf(back.type);
		return diffType!==0 ? diffType : fore.cid - back.cid;
	});
	let d = document.querySelector("#div-log");
	if(d){
		d.textContent = `✅️リソース取得完了。タイトルコール実装済みアイドルは ${arIdolDatas.length} 人です。`;
	}
	//全スクリーン共通の配置準備
	setupTitleScreen();
}

//ページ読み込み時処理
window.addEventListener("load", preFetch );

//^^^^^^^^ ここまで準備 ^^^^^^^^
//vvvvvvvv ここから本題 vvvvvvvv

//クイズに使う値
let indicesQuiz;
let countQuiz;
let countCorrect;
let countWrong;
let countStreak;
//クイズに使うHTMLElement
let HBEplay, HBEanswer; //HBE is <button>
let HSEquiz, HSEanswer; //HSE is <span>
//TODO:オブジェクトでひとまとめに……する？

//アイドル選択は one-and-only Object
let objChoice = {};
function init_objChoice(_dom, _aIdols){
	if(!( _dom instanceof DocumentFragment && _aIdols instanceof Array )){
		throw "init_objChoice() : bad args"
	}
	
	//初期化処理
	let d = _dom.querySelector("div#idol-choice")
	if(!d){ throw new Error("div#idol-choice is not found.") }
	d.addEventListener("change",objChoice);

	const tem = document.querySelector("template#icon-idol")
	if(!(tem instanceof HTMLTemplateElement)){
		throw new Error("template#icon-idol is not found.")
	}

	let g = [];
	for( let i=0 ; i<_aIdols.length ; ++i ){
		const cln = tem.content.cloneNode(true);
		if(!(cln instanceof DocumentFragment)){
			throw new Error("cloning made wrong")
		}
		let l = cln.querySelector("label");
		let c = cln.querySelector("input");
		if(c){
			c.value = i
			g.push(c);
		}
		const e = _aIdols[i][tIdol.pNmIMGicon];
		if(e instanceof HTMLImageElement){
			e.width = e.height = 50; //IMGの大きさを50[px]に、直接変更
			if(l){
				l.lastElementChild.remove();
				l.appendChild(e);
			}
		}
		d.appendChild(cln);
	}
	//変数＆関数登録
	objChoice.aIdols = _aIdols; //参照元tIdol配列
	objChoice.container = d;    //グリッドコンテナ
	objChoice.checkboxes = g;   //チェックボックス配列
	objChoice.needsChoice = 1;  //必要選択数(出題ごとに変わる可能性がある)
	objChoice.choicedIdolIndices = [];
	//[関数]解答欄準備
	objChoice.ready = (_answers)=>{
		objChoice.needsChoice = _answers;
		for( const c of objChoice.checkboxes ){ c.checked = false; }
		objChoice.choicedIdolIndices = [];
		HSEquiz.textContent = `答えは ${_answers} 人`;
		if(_answers>1){
			//特殊指定。
			HSEquiz.style.backgroundColor = "black";
			HSEquiz.style.color = "white";
			HSEquiz.style.fontWeight = "bold";
			HBEplay.classList.add("strong");
		}else{
			//特殊指定の解除
			HSEquiz.style.backgroundColor = "";
			HSEquiz.style.color = "";
			HSEquiz.style.fontWeight = "";
			HBEplay.classList.remove("strong");
		}
		HSEanswer.textContent = "";
	};
	//[関数]イベント捕捉
	objChoice.handleEvent = (ev)=>{
		if(ev.type === "change"){
			//choicedIdolIndicesの更新
			if(ev.target.checked){
				objChoice.choicedIdolIndices.push( parseInt(ev.target.value,10) );
				//余分にcheckされたら古いものをuncheck
				while( objChoice.choicedIdolIndices.length > objChoice.needsChoice ){
					let x = objChoice.choicedIdolIndices.shift();
					objChoice.checkboxes[x].checked = false;
				}
			}else{
				let i = objChoice.choicedIdolIndices.indexOf( parseInt(ev.target.value,10) );
				if( i >= 0 ){
					objChoice.choicedIdolIndices.splice(i,1);
				}
			}
			HSEanswer.textContent = idx2name(...objChoice.choicedIdolIndices); //選択情報更新
			HSEanswer.className = objChoice.choicedIdolIndices.length ? ("imascgss "+arIdolDatas[objChoice.choicedIdolIndices[0]].type) : "";
		} //ev.type="change"
	};
};
//使い方。
//解答欄のHTMLElementTreeは objChoice.container にある
//問題準備ができたら objChoice.ready( 正解の配列.length ) で解答欄リセット
//選ばれた数は objChoice.choicedIdolIndices.length
//正誤判定は objChoice.choicedIdolIndices と正解の配列の内容物をcompare

//ノード配置のクリア
function clearDivIO(){
	while(true){
		const e = document.body.lastElementChild;
		if( e instanceof HTMLScriptElement ){break;}
		e?.remove();
	}
}

//タイトル画面構成
function setupTitleScreen(){
	const d = document.querySelector("#div-output");
	if(d){
		d.textContent = "モード選択(予定地)";
	}
	const b = document.querySelector("#gotoQuiz");
	if(b instanceof HTMLButtonElement){
		b.addEventListener("click",
			//Chrome 66 以降、ページ読み込み時に生成されるAudioContextの初期が"suspend"に(＝いきなり音が鳴りださなくなる)
			//その対応として入力イベント処理中にaudctx.resume().then(action)。こっちの方が行儀がいい。
			gAudioCtx.resume().then( ()=>{
				setupQuizScreen();
			})
		);
		b.disabled = false;
	}
}

//クイズ画面構成
function setupQuizScreen(){
	//以降の画面で使われるHTMLElement群の初期化
	const clone = getCloneOfTemplateById("screen-quiz")

	init_objChoice(clone, arIdolDatas); //アイドル選択。

	//再生ボタン。
	HBEplay = clone.querySelector("button#HBEplay");
	if(HBEplay instanceof HTMLButtonElement){
		HBEplay.addEventListener("click",playQuizSound)
	}
	//回答ボタン。
	HBEanswer = clone.querySelector("button#HBEanswer");
	if(HBEanswer instanceof HTMLButtonElement){
		HBEanswer.addEventListener("click",judgeAnswer)
	}
	//情報表示用span
	HSEquiz = clone.querySelector("span#HSEquiz");
	HSEanswer = clone.querySelector("span#HSEanswer");

	//objChoice.container

	clearDivIO();
	document.body.appendChild(clone);

	countQuiz = countCorrect = countWrong = countStreak = 0;
	makeQuiz();
}

//出題(準備)する
function makeQuiz(){
	const elm = document.querySelector("span#HSEresult");
	if(elm){
		elm.textContent = `第 ${++countQuiz} 問 / 正 ${countCorrect}-${countWrong} 誤${
			countStreak<2 ? "" : (" !! "+countStreak+" COMBO")
		}`;
	}
	// ○-×日本式, ✓-✗米国式
	indicesQuiz = ( (_arr,_cnt)=>{
		let r = [], k = [..._arr.keys()]; //キーすなわち添え字のイテレータ　をスプレッド演算子で全展開
		while( r.length < _cnt ){ r.push( ...k.splice( (Math.random()*k.length)|0, 1 ) ); }
		return r;
	} )(arIdolDatas, (countStreak>=10)?2:1 ); //10問以上連続正解すると2人同時に(experimental)

	//解答欄準備
	objChoice.ready(indicesQuiz.length);
	//ボタンを使用可能にする
	HBEplay.disabled = false;
	HBEanswer.disabled = true;
}

//Promise版setTimeout(遅延時間[ms])
function promiseSetTimeout(_delay){
	return new Promise( (resolve,reject)=>{setTimeout(resolve,_delay);} );
}

//名前に変換
function idx2name(..._a){
	return _a.map( v=>arIdolDatas[v].name ).join("、");
}

//音声再生
function playQuizSound(){
	//まとめて、同時に再生
	let tim = gAudioCtx.currentTime;
	let pnm = indicesQuiz.length === 1 ? tIdol.pNmADtitleS : tIdol.pNmADtitleU;
	let dur = []; //音声の長さを取っておく
	for(let i of indicesQuiz){
		arIdolDatas[i].playAudio( pnm, gAudioCompNode, tim );
		dur.push( arIdolDatas[i].getDurationOf(pnm) );
	}

	//ボタンを使用不能にする
	HBEplay.disabled = true;
	promiseSetTimeout( Math.max(...dur)*1e3 ).then( ()=>{
		HBEanswer.disabled = false;
	}); //再生終了時間を待ってから
}

//正誤判定
function judgeAnswer(){
	HBEanswer.disabled = true;
	const bJudge = ((_x,_y)=>{
		if(_x.length !== _y.length) return false;
		for( let oy of _y ){ if( _x.indexOf(oy) < 0 ){ return false; } }
		return true; //つまり、長さが同じで一方の全要素が他方にも含まれていれば真
	})(indicesQuiz, objChoice.choicedIdolIndices);

	if(bJudge){
		++countCorrect;
		++countStreak;
	}else{
		++countWrong;
		countStreak = 0;
	}

	//本来は正誤表示を出し、待機して次の問題or前の画面へ
	console.log(
		countQuiz+(bJudge
			?"[O] "
			:`[X] ${idx2name(...objChoice.choicedIdolIndices)} ではなくて `
		)+idx2name(...indicesQuiz)
	);

	//正解は誰だったかがわかるように。
	let tim = gAudioCtx.currentTime;
	let totaldur = 0;
	for( let i=0 ; i<indicesQuiz.length; ++i ){
		let o = indicesQuiz[i];
		let p = (i+1 === indicesQuiz.length)? tIdol.pNmADnameD : tIdol.pNmADnameX; //最後のメンバのみ「～です」つき版にする
		arIdolDatas[o].playAudio(p,gAudioCompNode,tim+totaldur);
		totaldur+=arIdolDatas[o].getDurationOf(p);
	}
	promiseSetTimeout( totaldur*1e3 ).then( makeQuiz );
}

</script>
</body>
</html>

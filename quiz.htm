<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>デレステタイトルコール当てクイズ</title>
<style>

/* 共通設定 */
body{text-align:center}
h1{margin:.5em 0}
/* Fukol https://github.com/Heydon/fukol-grids */
.fukol-grid{display:flex;flex-wrap:wrap;margin:-.5em}
.fukol-grid>*{flex:1 0 5em;margin:.5em}
/* 属性色設定 */
.imascg-cute{color:#e26; background-color:#fdd}
.imascg-cool{color:#06f; background-color:#eef}
.imascg-passion{color:#c80; background-color:#feb}
/*その他、実験用*/
.quiz-log{color:silver}
.quiz-input{border:1px dashed green;margin:.3em;padding:.2em}
.quiz-output{border:1px dotted cyan;margin:.3em;padding:.2em}

/* animation (testing)*/
@keyframes sparkle-borderColor {
    0% { border-color:#999 }
    1% { border-color:#ccc }
    12% { border-color:#bbb }
    34% { border-color:#aaa }
    100% { border-color:#999 }
}
button {
    background-color: transparent;
    border:6px solid #999;
    border-radius: 16px;
    padding:10px;
}
button:enabled {
    animation: sparkle-borderColor 2s linear infinite both;
}
button:enabled:active { /* while down */
    border-style: inset;
}
button:enabled:focus {
    border-color: #3f6;
    animation-name:none
}
button:enabled:hover {
    background-color: #3f6;
}

</style></head><body><script>

"use strict";
const NEW_TAG = (tag) => document.createElement(tag);
const GET_ID = (id) => document.getElementById(id);

// AudioContext初期化 by Mozilla
const gAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Webkit/blink系ブラウザは接頭辞が必要、Safariは「window.」をつけないと動かない
const gURL = window.URL || window.webkitURL; //URLも同様らしいのでそうしておく

const hostStarlightDB = "https://starlight.kirara.ca/";
const pathCharList = "/api/v1/list/char_t?keys=chara_id";
const pathCharDetail = "/api/v1/char_t/";
//URLインターフェースを利用して引数を安全にURL化(さもなくば例外を投げる)
const urlFirstRequest = new gURL(pathCharList,hostStarlightDB);
const urlVirtualRequest = new gURL( pathCharDetail, hostStarlightDB );

let arIdolDatas = [];
let arIdolLoaders = [];
let divLog = null;
let divInput = null;
let divOutput = null;

class tIdol {
	//クラス用定数
	static get pNmIMGicon(){ return "IMGicon"; }
	static get pNmADtitleS(){ return "ADtitleS"; }
	static get pNmADtitleU(){ return "ADtitleU"; }
	static get pNmADnameD(){ return "ADnameD"; }
	static get pNmADnameX(){ return "ADnameX"; }

	//**コンストラクタ**
	constructor( _argobj ){
		//同一名称プロパティをコピーしまくりんぐ
		const copyProprts = (a)=>{ for(const n of a){ this[n] = _argobj[n]; } };
		copyProprts( [
			"cid","name","type","voice", this.constructor.pNmIMGicon,
			this.constructor.pNmADtitleS, this.constructor.pNmADtitleU, this.constructor.pNmADnameD, this.constructor.pNmADnameX
		] );
		this[ this.constructor.pNmIMGicon ].alt = `${this.name} (cv. ${this.voice})`;
	}

	//プロパティ名を指定して音声再生
	playAudio( _pName, _dest, _timing ){
		let bfsrc = gAudioCtx.createBufferSource();
		bfsrc.buffer = this[ _pName ? _pName : this.constructor.pNmADtitleS ];
		bfsrc.connect( _dest ? _dest : gAudioCtx.destination );
		bfsrc.start( _timing ? _timing : gAudioCtx.currentTime );
		return true;
	}
}

class tIdolLoader {

	//**コンストラクタ**
	constructor( _argobj ){
		//必要な情報を抜き取る(含・tIdol生成時にのみ必要なもの)
		this.cid = _argobj["chara_id"]; //ID
		this.name = _argobj["name"];    //名前
		this.type = _argobj["type"];    //属性
		this.voice = _argobj["voice"];  //担当声優
		//アイコン画像のURLは絶対参照に変換して保存
		this.urlIcon = new gURL( _argobj["icon_image_ref"], urlVirtualRequest ).href;
	}

	//非同期読み込み開始
	async asyncLoad( _fnFinally ){
		// ++非同期関数++ URLから音声データにする
		const asyncGetAudioData = async ( _href )=>{
			let aud;
			try {
				const rsp = await fetch(_href);
				const abf = await rsp.arrayBuffer();
				aud = await gAudioCtx.decodeAudioData(abf);
			} catch (e) {
				aud = null;
			}
			return aud;
		};
		// ++非同期関数++ URLから画像を取得
		const promiseGetImage = ( _href )=>{
			return new Promise( (resolve,reject)=>{
				let hie = NEW_TAG("img");
				hie.onload = ()=>{ resolve(hie); };
				hie.onerror = (e)=>{ reject(e); };
				hie.src = _href;
			} );
		};

		//アイドル個人の情報のvoiceが空文字列ではない＝タイトルコールがある「かもしれない」。
		//例えば2017年の「恋が咲く季節」イベントの時(だと思われる)、この曲を歌うアイドルのCV 5名分 が反映されたものの、
		//タイトルコール実装はカード報酬となった2名にとどまっている。
		//タイトルコールが存在するかは個人情報JSONに現れないので直接音声ファイルのURLを叩いてみる。
		const id2vo = c => `/va2/${ (this.cid ^ 0x1042fc).toString(16) }10442${c}16ab.mp3`;
		//本家ソースちら見した限り、音声は画像と同じサーバにあるらしい。
		const urlTitleS = new gURL( id2vo("c"), this.urlIcon ).href; //タイトルコール/ソロ用
		const urlTitleU = new gURL( id2vo("d"), this.urlIcon ).href; //タイトルコール/ユニット用
		const urlNameD = new gURL( id2vo("2"), this.urlIcon ).href;  //名前＋です
		const urlNameX = new gURL( id2vo("1"), this.urlIcon ).href;  //名前(体言止め)

		try {
			this[tIdol.pNmADtitleS] = await asyncGetAudioData(urlTitleS);
			if( ! this[tIdol.pNmADtitleS] ){ throw "if there is HTTP:404 then never mind."; }
			//引き続き、残る要素を読み込む。並列処理テクを使う。
			//1. await抜きでasync関数を呼び出すことでPromiseを生成(実行開始)。
			const prmIcon = promiseGetImage(this.urlIcon);
			const prmTitleU = asyncGetAudioData(urlTitleU);
			const prmNameD = asyncGetAudioData(urlNameD);
			const prmNameX = asyncGetAudioData(urlNameX);
			//2. そのPromiseインスタンスをawaitする。Promise群の中で一番遅いものの時間で処理できる。
			this[tIdol.pNmIMGicon] = await prmIcon;
			this[tIdol.pNmADtitleU] = await prmTitleU;
			this[tIdol.pNmADnameD] = await prmNameD;
			this[tIdol.pNmADnameX] = await prmNameX;
		} catch (e) {
			//読み込めなかったらこのブロックに来てからfinallyブロックへ
			console.log(e);
		} finally {
			_fnFinally( this );
		}
	}

	//class tIdol のインスタンスを取り出す。さもなくば return null
	standIdol(){
		return (
			this[tIdol.pNmIMGicon] && this[tIdol.pNmADtitleS] && this[tIdol.pNmADtitleU] && this[tIdol.pNmADnameD] && this[tIdol.pNmADnameX]
		)? new tIdol(this) : null;
	}
}

// ++非同期関数++ リソースの読み出し
async function asyncFetchResources() {

	// ++非同期関数++ 問い合わせてレスポンスのJSONをオブジェクトに変換して返す。
	const asyncFetchAndStrip = async ( url ) => {
		const resReq = await fetch( url.href );
		return (await resReq.json())["result"];
	};

	let arrslt = await asyncFetchAndStrip(urlFirstRequest);
	//最初の結果を利用して次に呼び出すURLを構築
	let strCharIds = "";
	for( const s of arrslt ){ strCharIds += (strCharIds.length>0 ? `,${s["chara_id"]}` : s["chara_id"]); }
	let secondRequestURL = new gURL(pathCharDetail+strCharIds, urlFirstRequest);
	arrslt = await asyncFetchAndStrip(secondRequestURL);

	for( let objrslt of arrslt ){
		if( ! objrslt["voice"] ) continue;
		//専用のローダーに返答オブジェクトを渡せば良いようにしてあります
		let idldr = new tIdolLoader(objrslt);
		arIdolLoaders.push( idldr );
		idldr.asyncLoad( cbIdolLoader );
	}
	console.log(`(asyncFetchResources) 全 ${arrslt.length} 人、CV設定あり ${arIdolLoaders.length} 人`);
}

//callback of tIdolLoaer
function cbIdolLoader( _objILr ){

	//インスタンスを取り出せれば配列に登録。
	let objIdol = _objILr.standIdol();
	if( objIdol ){ arIdolDatas.push( objIdol ); }

	//処理が終わったので、配列から取り除く
	const idxILs = arIdolLoaders.indexOf( _objILr );
	if( idxILs < 0 ) throw new Error("cbIdolLoader() / unknown tIdolLoader object found");
	arIdolLoaders.splice( idxILs,　1　);

	//状態更新(反映)処理を呼ぶ
	//console.log(`(cbIdolLoader) 結果=${!!objIdol} 成功x${arIdolDatas.length} 残件x${arIdolLoaders.length}`);
	progressFetch();
	if( arIdolLoaders.length == 0 ){ afterFetch(); }
}

//リソース読み出し前処理
function beforeFetch(){
	let h = NEW_TAG("h1");
	h.textContent = document.title;
	document.body.appendChild( h );
	document.body.appendChild( divLog = NEW_TAG("div") );
	divLog.textContent = "リソース取得中...";
}

//リソース読み出し中処理
function progressFetch(){
	divLog.textContent = `リソース取得中... x${arIdolDatas.length}+${arIdolLoaders.length}?`;
}

//リソース読み出し後処理
function afterFetch(){
	//ID順・昇順に整列。リソース読み出し完了は順不同になるため。
	arIdolDatas.sort( (fore,back) => fore.cid - back.cid );
	divLog.textContent = `リソース取得完了。タイトルコール実装済みアイドルは ${arIdolDatas.length} 人です。`;
	//全スクリーン共通の配置準備
	document.body.appendChild( divOutput = NEW_TAG("div") );
	document.body.appendChild( divInput = NEW_TAG("div") );
	divOutput.className = "quiz-output";
	divInput.className = "quiz-input";
	divLog.className = "quiz-log"; //ログメッセージ表示部が目立たなくなる(これ以降変化しないが、隠すには惜しい情報)
	initScreenElements();
	setupTitleScreen();
}

//ページ読み込み時処理
window.addEventListener("load", ()=>{ beforeFetch(); asyncFetchResources(); } );

//^^^^^^^^ ここまで準備 ^^^^^^^^
//vvvvvvvv ここから本題 vvvvvvvv

//クイズに使う値
let indexQuiz;
let countQuiz;
let countCorrect;
let countWrong;
//クイズに使うHTMLElement
let HSEchoice; //HSE is <select>
let HBEplay;   //HBE is <button>
let HBEanswer;
//TODO:オブジェクトでひとまとめに……する？

//以降の画面で使われるHTMLElement群の初期化
function initScreenElements(){
	//アイドル選択。本当はプルダウンじゃなくてアイコンタップにしたい
	HSEchoice = NEW_TAG("select");
	for (const d of arIdolDatas) {
		const o = new Option( d.name, d.name );
		o.className = "imascg-"+d.type;
		HSEchoice.add( o );
	}
	HSEchoice.onchange = ()=>{
		HSEchoice.className = HSEchoice.selectedOptions[0].className;
	};

	//再生ボタン。
	HBEplay = NEW_TAG("button");
	HBEplay.funcChangeEnable = (b)=>{
		HBEplay.disabled = !b;
		HBEplay.textContent = b ? "PLAY" : ">>>>";
	};
	HBEplay.onclick = playQuizSound;

	//回答ボタン。
	HBEanswer = NEW_TAG("button");
	HBEanswer.funcChangeEnable = (b)=>{
		HBEanswer.disabled = !b;
		HBEanswer.textContent = b ? "ANSWER" : "------";
	};
	HBEanswer.onclick = judgeAnswer;
}

//子ノードを全部外す
function clearDivIO(){
	const detach = (n)=>{ while(n.lastChild){ n.removeChild(n.lastChild); } };
	detach(divOutput);
	detach(divInput);
}

//タイトル画面構成
function setupTitleScreen(){
	clearDivIO();
	
	const p = NEW_TAG("span");
	p.textContent = "モード選択";
	divOutput.appendChild(p);

	const b = NEW_TAG("button");
	b.textContent = "START";
	b.onclick = ()=>{ setupQuizScreen(); };
	divInput.appendChild(b);
}

//クイズ画面構成
function setupQuizScreen(){
	clearDivIO();

	//TODO:使うHTMLElementたちはもっと前に作れるし、参照をどこかで取っておける
	const p = NEW_TAG("span");
	divOutput.appendChild(p);
	divOutput.appendChild( NEW_TAG("br") );

	divOutput.appendChild(HBEplay);

	divInput.appendChild(HSEchoice);
	divInput.appendChild( NEW_TAG("br") );
	divInput.appendChild(HBEanswer);

	countQuiz = countCorrect = countWrong = 0;
	makeQuiz();
}

//出題(準備)する
function makeQuiz(){
	divOutput.firstChild.textContent = `第 ${++countQuiz} 問 / ${countCorrect}-${countWrong}`;
	indexQuiz = (Math.random()*arIdolDatas.length)|0;
	//ボタンを使用可能にする
	HBEplay.funcChangeEnable(true);
	HBEanswer.funcChangeEnable(false);
}

//音声再生
function playQuizSound(){
	arIdolDatas[indexQuiz].playAudio(tIdol.pNmADtitleS);
	//ボタンを使用不能にする
	HBEplay.funcChangeEnable(false);
	HBEanswer.funcChangeEnable(true);
}

//正誤判定
function judgeAnswer(){
	const bJudge = indexQuiz === HSEchoice.selectedIndex;
	bJudge ? ++countCorrect : ++countWrong ;
	//本来は正誤表示を出し、待機して次の問題or前の画面へ
	console.log(
		countQuiz+(bJudge
			?"[O]"
			:`[X]${arIdolDatas[HSEchoice.selectedIndex].name} ではなくて `
		)+arIdolDatas[indexQuiz].name
	);
	//正解は誰だったかがわかるように。
	arIdolDatas[indexQuiz].playAudio(tIdol.pNmADnameD);
	makeQuiz();
}

</script>
</body>
</html>

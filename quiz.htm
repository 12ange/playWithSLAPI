<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<title>デレステタイトルコール当てクイズ</title>
<style>

/* 共通設定 */
body{text-align:center}
h1{margin:.5em 0}
/* based on Fukol https://github.com/Heydon/fukol-grids */
.inlfklgrid{display:inline-flex;flex-wrap:wrap;margin:-.5em}
.inlfklgrid>*{flex:1 0 5em;margin:.5em}
/* 属性色設定 */
.imascg-cute{color:#e26; background-color:#fdd}
.imascg-cool{color:#06f; background-color:#eef}
.imascg-passion{color:#c80; background-color:#feb}
/*その他、実験用*/
.quiz-log{color:silver}
.quiz-input{border:1px dashed green;margin:.3em;padding:.2em}
.quiz-output{border:1px dotted cyan;margin:.3em;padding:.2em}


/* animation (testing)*/
@keyframes sparkle-borderColor {
    0% { border-color:#999 }
    1% { border-color:#ccc }
    12% { border-color:#bbb }
    34% { border-color:#aaa }
    100% { border-color:#999 }
}
button {
    background-color: transparent;
    border:6px solid #999;
    border-radius: 16px;
    padding:10px;
}
button:enabled {
    animation: sparkle-borderColor 2s linear infinite both;
}
button:enabled:active { /* while down */
    border-style: inset;
}
button:enabled:focus {
    border-color: #3f6;
    animation-name:none
}
button:enabled:hover {
    background-color: #3f6;
}

</style></head><body><script>

"use strict";
const NEW_TAG = (tag) => document.createElement(tag);
const GET_ID = (id) => document.getElementById(id);

// AudioContext初期化 by Mozilla
const gAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Webkit/blink系ブラウザは接頭辞が必要、Safariは「window.」をつけないと動かない
const gURL = window.URL || window.webkitURL; //URLも同様らしいのでそうしておく

const msgPlzHoldOn = "⌛リソース取得中..."; //PLEASE HOLD ON
const msgFineFetch = "✅️リソース取得完了。タイトルコール実装済みアイドルは";
const msgFineFetch2 = "人です。";

const hostStarlightDB = "https://starlight.kirara.ca/";
const pathCharList = "/api/v1/list/char_t?keys=chara_id";
const pathCharDetail = "/api/v1/char_t/";
//URLインターフェースを利用して引数を安全にURL化(さもなくば例外を投げる)
const urlFirstRequest = new gURL(pathCharList,hostStarlightDB);
const urlVirtualRequest = new gURL( pathCharDetail, hostStarlightDB );

let arIdolDatas = [];
let arIdolLoaders = [];
let divLog = null;
let divInput = null;
let divOutput = null;

class tIdol {
	//クラス用定数
	static get pNmIMGicon(){ return "IMGicon"; }
	static get pNmADtitleS(){ return "ADtitleS"; } //タイトルコール/ソロ用
	static get pNmADtitleU(){ return "ADtitleU"; } //タイトルコール/ユニット用
	static get pNmADnameD(){ return "ADnameD"; }   //名前＋です
	static get pNmADnameX(){ return "ADnameX"; }   //名前(体言止め)

	//**コンストラクタ**
	constructor( _argobj ){
		//同一名称プロパティをコピーしまくりんぐ
		const copyProprts = (a)=>{ for(const n of a){ this[n] = _argobj[n]; } };
		copyProprts( [
			"cid","name","type","voice", this.constructor.pNmIMGicon,
			this.constructor.pNmADtitleS, this.constructor.pNmADtitleU, this.constructor.pNmADnameD, this.constructor.pNmADnameX
		] );
		this[ this.constructor.pNmIMGicon ].alt = `${this.name} (cv. ${this.voice})`;
	}

	//プロパティ名を指定して音声再生
	playAudio(
		_pName = this.constructor.pNmADtitleS,
		_dest = gAudioCtx.destination,
		_timing = gAudioCtx.currentTime
	){
		let bfsrc = gAudioCtx.createBufferSource();
		bfsrc.buffer = this[_pName];
		bfsrc.connect(_dest);
		bfsrc.start(_timing);
		return true;
	}

	//プロパティ名を指定して音声長[秒]を取得
	getDurationOf(_pName){
		const tgtpnm = "duration";
		return ( _pName in this && tgtpnm in this[_pName] )? this[_pName][tgtpnm] : 0;
	}
}

class tIdolLoader {

	//**コンストラクタ**
	constructor( _argobj ){
		//必要な情報を抜き取る(含・tIdol生成時にのみ必要なもの)
		this.cid = _argobj["chara_id"]; //ID
		this.name = _argobj["name"];    //名前
		this.type = _argobj["type"];    //属性
		this.voice = _argobj["voice"];  //担当声優
		//アイコン画像のURLは絶対参照に変換して保存
		this.urlIcon = new gURL( _argobj["icon_image_ref"], urlVirtualRequest ).href;
	}

	//非同期読み込み開始
	async asyncLoad( _fnFinally ){
		// ++非同期関数++ URLから音声データにする
		const asyncGetAudioData = async ( _href )=>{
			let aud;
			try {
				const rsp = await fetch(_href);
				const abf = await rsp.arrayBuffer();
				aud = await gAudioCtx.decodeAudioData(abf);
			} catch (e) {
				aud = null;
			}
			return aud;
		};
		// ++非同期関数++ URLから画像を取得
		const promiseGetImage = ( _href )=>{
			return new Promise( (resolve,reject)=>{
				let hie = NEW_TAG("img");
				hie.onload = ()=>{ resolve(hie); };
				hie.onerror = (e)=>{ reject(e); };
				hie.src = _href;
			} );
		};

		//アイドル個人の情報のvoiceが空文字列ではない＝タイトルコールがある「かもしれない」。
		//例えば2017年の「恋が咲く季節」イベントの時(だと思われる)、この曲を歌うアイドルのCV 5名分 が反映されたものの、
		//タイトルコール実装はカード報酬となった2名にとどまっている。
		//タイトルコールが存在するかは個人情報JSONに現れないので直接音声ファイルのURLを叩いてみる。
		const id2vo = c => `/va2/${ (this.cid ^ 0x1042fc).toString(16) }10442${c}16ab.mp3`;
		//本家ソースちら見した限り、音声は画像と同じサーバにあるらしい。
		const urlTitleS = new gURL( id2vo("c"), this.urlIcon ).href; //タイトルコール/ソロ用
		const urlTitleU = new gURL( id2vo("d"), this.urlIcon ).href; //タイトルコール/ユニット用
		const urlNameD = new gURL( id2vo("2"), this.urlIcon ).href;  //名前＋です
		const urlNameX = new gURL( id2vo("1"), this.urlIcon ).href;  //名前(体言止め)

		try {
			this[tIdol.pNmADtitleS] = await asyncGetAudioData(urlTitleS);
			if( ! this[tIdol.pNmADtitleS] ){ throw "if there is HTTP:404 then never mind."; }
			//引き続き、残る要素を読み込む。並列処理テクを使う。
			//1. await抜きでasync関数を呼び出すことでPromiseを生成(実行開始)。
			const prmIcon = promiseGetImage(this.urlIcon);
			const prmTitleU = asyncGetAudioData(urlTitleU);
			const prmNameD = asyncGetAudioData(urlNameD);
			const prmNameX = asyncGetAudioData(urlNameX);
			//2. そのPromiseインスタンスをawaitする。Promise群の中で一番遅いものの時間で処理できる。
			this[tIdol.pNmIMGicon] = await prmIcon;
			this[tIdol.pNmADtitleU] = await prmTitleU;
			this[tIdol.pNmADnameD] = await prmNameD;
			this[tIdol.pNmADnameX] = await prmNameX;
		} catch (e) {
			//読み込めなかったらこのブロックに来てからfinallyブロックへ
			console.log(e);
		} finally {
			_fnFinally( this );
		}
	}

	//class tIdol のインスタンスを取り出す。さもなくば return null
	standIdol(){
		return (
			this[tIdol.pNmIMGicon] && this[tIdol.pNmADtitleS] && this[tIdol.pNmADtitleU] && this[tIdol.pNmADnameD] && this[tIdol.pNmADnameX]
		)? new tIdol(this) : null;
	}
}

// ++非同期関数++ リソースの読み出し
async function asyncFetchResources() {

	// ++非同期関数++ 問い合わせてレスポンスのJSONをオブジェクトに変換して返す。
	const asyncFetchAndStrip = async ( url ) => {
		const resReq = await fetch( url.href );
		return (await resReq.json())["result"];
	};

	let arrslt = await asyncFetchAndStrip(urlFirstRequest);
	//最初の結果を利用して次に呼び出すURLを構築
	let strCharIds = "";
	for( const s of arrslt ){ strCharIds += (strCharIds.length>0 ? `,${s["chara_id"]}` : s["chara_id"]); }
	let secondRequestURL = new gURL(pathCharDetail+strCharIds, urlFirstRequest);
	arrslt = await asyncFetchAndStrip(secondRequestURL);

	for( let objrslt of arrslt ){
		if( ! objrslt["voice"] ) continue;
		//専用のローダーに返答オブジェクトを渡せば良いようにしてあります
		let idldr = new tIdolLoader(objrslt);
		arIdolLoaders.push( idldr );
		idldr.asyncLoad( cbIdolLoader );
	}
	console.log(`(asyncFetchResources) 全 ${arrslt.length} 人、CV設定あり ${arIdolLoaders.length} 人`);
}

//callback of tIdolLoaer
function cbIdolLoader( _objILr ){

	//インスタンスを取り出せれば配列に登録。
	let objIdol = _objILr.standIdol();
	if( objIdol ){ arIdolDatas.push( objIdol ); }

	//処理が終わったので、配列から取り除く
	const idxILs = arIdolLoaders.indexOf( _objILr );
	if( idxILs < 0 ) throw new Error("cbIdolLoader() / unknown tIdolLoader object found");
	arIdolLoaders.splice( idxILs,　1　);

	//状態更新(反映)処理を呼ぶ
	//console.log(`(cbIdolLoader) 結果=${!!objIdol} 成功x${arIdolDatas.length} 残件x${arIdolLoaders.length}`);
	progressFetch();
	if( arIdolLoaders.length == 0 ){ afterFetch(); }
}

//リソース読み出し前処理
function beforeFetch(){
	let h = NEW_TAG("h1");
	h.textContent = document.title;
	document.body.appendChild( h );
	document.body.appendChild( divLog = NEW_TAG("div") );
	divLog.textContent = msgPlzHoldOn;
	document.body.appendChild( divOutput = NEW_TAG("div") );
	//divOutput.appendChild(); 待機アニメーション予定地
}

//リソース読み出し中処理
function progressFetch(){
	divLog.textContent = `${msgPlzHoldOn} x${arIdolDatas.length}+${arIdolLoaders.length}?`;
}

//リソース読み出し後処理
function afterFetch(){
	//ID順・昇順に整列。リソース読み出し完了は順不同になるため。
	arIdolDatas.sort( (fore,back) => fore.cid - back.cid );
	divLog.textContent = `${msgFineFetch} ${arIdolDatas.length} ${msgFineFetch2}`;
	//全スクリーン共通の配置準備
	document.body.appendChild( divInput = NEW_TAG("div") );
	divOutput.className = "quiz-output";
	divInput.className = "quiz-input";
	divLog.className = "quiz-log"; //ログメッセージ表示部が目立たなくなる(これ以降変化しないが、隠すには惜しい情報)
	initScreenElements();
	setupTitleScreen();
}

//ページ読み込み時処理
window.addEventListener("load", ()=>{ beforeFetch(); asyncFetchResources(); } );

//^^^^^^^^ ここまで準備 ^^^^^^^^
//vvvvvvvv ここから本題 vvvvvvvv

//クイズに使う値
let indicesQuiz;
let countQuiz;
let countCorrect;
let countWrong;
//クイズに使うHTMLElement
let HBEplay;   //HBE is <button>
let HBEanswer;
//TODO:オブジェクトでひとまとめに……する？

//アイドル選択は one-and-only Object
let objChoice = {};
function init_objChoice(_aIdols){
	//初期化処理
	let d = NEW_TAG("div");
	d.className = "inlfklgrid";
	d.addEventListener("change",objChoice);
	let g = [];
	for( let i=0 ; i<_aIdols.length ; ++i ){
		let l = d.appendChild( NEW_TAG("label") );
		let c = l.appendChild( NEW_TAG("input") );
		c.type = "checkbox";
		c.value = i;
		g.push(c);
		l.appendChild(_aIdols[i][tIdol.pNmIMGicon]);
	}
	//変数＆関数登録
	objChoice.aIdols = _aIdols; //参照元tIdol配列
	objChoice.container = d;    //グリッドコンテナ
	objChoice.checkboxes = g;   //チェックボックス配列
	objChoice.needsChoice = 1;  //必要選択数(出題ごとに変わる可能性がある)
	objChoice.choicedIdolIndices = [];
	//[関数]解答欄準備
	objChoice.ready = (_answers)=>{
		objChoice.needsChoice = _answers;
		for( const c of objChoice.checkboxes ){ c.checked = false; }
		objChoice.choicedIdolIndices = [];
	};
	//[関数]イベント捕捉
	objChoice.handleEvent = (ev)=>{
		if(ev.type === "change"){
			//choicedIdolIndicesの更新
			if(ev.target.checked){
				objChoice.choicedIdolIndices.push( parseInt(ev.target.value,10) );
				//余分にcheckされたら古いものをuncheck
				while( objChoice.choicedIdolIndices.length > objChoice.needsChoice ){
					let x = objChoice.choicedIdolIndices.shift();
					objChoice.checkboxes[x].checked = false;
				}
			}else{
				let i = objChoice.choicedIdolIndices.indexOf( parseInt(ev.target.value,10) );
				if( i >= 0 ){
					objChoice.choicedIdolIndices.splice(i,1);
				}
			}
		}
	};
};
//使い方。
//init_objChoice( arIdolDatas ) は initScreenElements で呼ばせる
//解答欄のHTMLElementTreeは objChoice.container にある
//問題準備ができたら objChoice.ready( 正解の配列.length ) で解答欄リセット
//選ばれた数は objChoice.choicedIdolIndices.length
//正誤判定は objChoice.choicedIdolIndices と正解の配列の内容物をcompare

//以降の画面で使われるHTMLElement群の初期化
function initScreenElements(){
	//アイドル選択。
	init_objChoice(arIdolDatas);

	//再生ボタン。
	HBEplay = NEW_TAG("button");
	HBEplay.funcChangeEnable = (b)=>{
		HBEplay.disabled = !b;
		HBEplay.textContent = b ? "PLAY" : ">>>>";
	};
	HBEplay.onclick = playQuizSound;

	//回答ボタン。
	HBEanswer = NEW_TAG("button");
	HBEanswer.funcChangeEnable = (b)=>{
		HBEanswer.disabled = !b;
		HBEanswer.textContent = b ? "ANSWER" : "------";
	};
	HBEanswer.onclick = judgeAnswer;
}

//子ノードを全部外す
function clearDivIO(){
	const detach = (n)=>{ while(n.lastChild){ n.removeChild(n.lastChild); } };
	detach(divOutput);
	detach(divInput);
}

//タイトル画面構成
function setupTitleScreen(){
	clearDivIO();
	
	const p = NEW_TAG("span");
	p.textContent = "モード選択(予定地)";
	divOutput.appendChild(p);

	const b = NEW_TAG("button");
	b.textContent = "START";
	b.onclick = ()=>{ setupQuizScreen(); };
	divInput.appendChild(b);
}

//クイズ画面構成
function setupQuizScreen(){
	clearDivIO();

	//TODO:使うHTMLElementたちはもっと前に作れるし、参照をどこかで取っておける
	const p = NEW_TAG("span");
	divOutput.appendChild(p);
	divOutput.appendChild( NEW_TAG("br") );

	divOutput.appendChild(HBEplay);

	divInput.appendChild(objChoice.container);
	divInput.appendChild( NEW_TAG("br") );
	divInput.appendChild(HBEanswer);

	countQuiz = countCorrect = countWrong = 0;
	makeQuiz();
}

//出題(準備)する
function makeQuiz(){
	divOutput.firstChild.textContent = `第 ${++countQuiz} 問 / 正 ${countCorrect}-${countWrong} 誤`;
	// ○-×日本式, ✓-✗米国式
	indicesQuiz = ( (_arr,_cnt)=>{
		let r = [], k = [..._arr.keys()]; //キーすなわち添え字のイテレータ　をスプレッド演算子で全展開
		while( r.length < _cnt ){ r.push( ...k.splice( (Math.random()*k.length)|0, 1 ) ); }
		return r;
	} )(arIdolDatas,1);

	//解答欄準備
	objChoice.ready(indicesQuiz.length);
	//ボタンを使用可能にする
	HBEplay.funcChangeEnable(true);
	HBEanswer.funcChangeEnable(false);
}

//Promise版setTimeout(遅延時間[ms])
function promiseSetTimeout(_delay){
	return new Promise( (resolve,reject)=>{setTimeout(resolve,_delay);} );
}

//音声再生
function playQuizSound(){
	//まとめて、同時に再生
	let dst = gAudioCtx.destination;
	let tim = gAudioCtx.currentTime;
	let pnm = indicesQuiz.length === 1 ? tIdol.pNmADtitleS : tIdol.pNmADtitleU;
	let dur = []; //音声の長さを取っておく
	for(let i of indicesQuiz){
		arIdolDatas[i].playAudio( pnm, dst, tim );
		dur.push( arIdolDatas[i].getDurationOf(pnm) );
	}

	//ボタンを使用不能にする
	HBEplay.funcChangeEnable(false);
	promiseSetTimeout( Math.max(...dur)*1e3 ).then(
		()=>{HBEanswer.funcChangeEnable(true);} //再生終了時間を待ってから
	);
}

//正誤判定
function judgeAnswer(){
	const bJudge = ((_x,_y)=>{
		if(_x.length !== _y.length) return false;
		for( let oy of _y ){ if( _x.indexOf(oy) < 0 ){ return false; } }
		return true; //つまり、長さが同じで一方の全要素が他方にも含まれていれば真
	})(indicesQuiz, objChoice.choicedIdolIndices);

	bJudge ? ++countCorrect : ++countWrong ;

	//本来は正誤表示を出し、待機して次の問題or前の画面へ
	const idx2name = (_a)=>{
		let r = "";
		for( let c of _a ){
			r += (r.length ? "," : "[") + arIdolDatas[c].name;
		}
		return r+"]";
	};
	console.log(
		countQuiz+(bJudge
			?"[O] "
			:`[X] ${idx2name(objChoice.choicedIdolIndices)} ではなくて `
		)+idx2name(indicesQuiz)
	);

	//正解は誰だったかがわかるように。
	let dst = gAudioCtx.destination;
	let tim = gAudioCtx.currentTime;
	let totaldur = 0;
	for( let i=0 ; i<indicesQuiz.length; ++i ){
		let o = indicesQuiz[i];
		let p = (i+1 === indicesQuiz.length)? tIdol.pNmADnameD : tIdol.pNmADnameX; //最後のメンバのみ「～です」つき版にする
		arIdolDatas[o].playAudio(p,dst,tim+totaldur);
		totaldur+=arIdolDatas[o].getDurationOf(p);
	}
	promiseSetTimeout( totaldur*1e3 ).then( makeQuiz );
}

</script>
</body>
</html>

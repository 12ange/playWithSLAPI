<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>タイトルコール当てクイズ</title>
<style type="text/css">

/* Fukol https://github.com/Heydon/fukol-grids */
.fukol-grid{display:flex;flex-wrap:wrap;margin:-.5em;}
.fukol-grid>*{flex:1 0 5em;margin:.5em;}
/* 属性色設定 */
.imascg-cute{color:#e26; background-color:#fdd}
.imascg-cool{color:#06f; background-color:#eef}
.imascg-passion{color:#c80; background-color:#feb}

</style>
</head>
<body>
<script>

"use strict";
const NEW_TAG = (tag) => document.createElement(tag);
const GET_ID = (id) => document.getElementById(id);

// AudioContext初期化 by Mozilla
const gAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Webkit/blink系ブラウザは接頭辞が必要、Safariは「window.」をつけないと動かない
const gURL = window.URL || window.webkitURL; //URLも同様らしいのでそうしておく

const hostStarlightDB = "https://starlight.kirara.ca/";
const pathCharList = "/api/v1/list/char_t?keys=chara_id";
const pathCharDetail = "/api/v1/char_t/";
//URLインターフェースを利用して引数を安全にURL化(さもなくば例外を投げる)
const urlFirstRequest = new gURL(pathCharList,hostStarlightDB);
const urlVirtualRequest = new gURL( pathCharDetail, hostStarlightDB );

let arIdolDatas = [];
let arIdolLoaders = [];
let divLog = null;
let divFukol = null;

class tIdol {
	//クラス用定数
	static get pNmIMGicon(){ return "IMGicon"; }
	static get pNmADtitle1(){ return "ADtitle1"; }

	//**コンストラクタ**
	constructor( _argobj ){
		//同一名称プロパティをコピーしまくりんぐ
		this.cid = _argobj["cid"];
		this.name = _argobj["name"];
		this.type = _argobj["type"];
		this.voice = _argobj["voice"];
		this[ this.constructor.pNmIMGicon ] = _argobj[ this.constructor.pNmIMGicon ];
		this[ this.constructor.pNmADtitle1 ] = _argobj[ this.constructor.pNmADtitle1 ];
		this[ this.constructor.pNmIMGicon ].alt = `${this.name} (cv. ${this.voice})`;
	}

	//プロパティ名を指定して音声再生
	playAudio( _pName, _dest, _timing ){
		let bfsrc = gAudioCtx.createBufferSource();
		bfsrc.buffer = this[ _pName ];
		bfsrc.connect( _dest );
		bfsrc.start( _timing );
		return true;
	}
}

class tIdolLoader {

	//**コンストラクタ**
	constructor( _argobj ){
		//必要な情報を抜き取る(含・tIdol生成時にのみ必要なもの)
		this.cid = _argobj["chara_id"]; //ID
		this.name = _argobj["name"];    //名前
		this.type = _argobj["type"];    //属性
		this.voice = _argobj["voice"];  //担当声優
		//アイコン画像のURLは絶対参照に変換して保存
		this.urlIcon = new gURL( _argobj["icon_image_ref"], urlVirtualRequest ).href;
	}

	//非同期読み込み開始
	async asyncLoad( _fnFinally ){
		// ++非同期関数++ URLから音声データにする
		const asyncGetAudioData = async ( _href )=>{
			let aud;
			try {
				const rsp = await fetch(_href);
				const abf = await rsp.arrayBuffer();
				aud = await gAudioCtx.decodeAudioData(abf);
			} catch (e) {
				aud = null;
			}
			return aud;
		};
		// ++非同期関数++ URLから
		const promiseGetImage = ( _href )=>{
			return new Promise( (resolve,reject)=>{
				let hie = NEW_TAG("img");
				hie.onload = ()=>{ resolve(hie); };
				hie.onerror = (e)=>{ reject(e); };
				hie.src = _href;
			} );
		};

		//アイドル個人の情報のvoiceが空文字列ではない＝タイトルコールがある「かもしれない」。
		//例えば2017年の「恋が咲く季節」イベントの時(だと思われる)、この曲を歌うアイドルのCV 5名分 が反映されたものの、
		//タイトルコール実装はカード報酬となった2名にとどまっている。
		//タイトルコールが存在するかは個人情報JSONに現れないので直接音声ファイルのURLを叩いてみる。
		const id2vo = c => `/va2/${ (this.cid ^ 0x1042fc).toString(16) }10442${c}16ab.mp3`;
		//本家ソースちら見した限り、音声は画像と同じサーバにあるらしい。
		const urlTitleS = new gURL( id2vo("c"), this.urlIcon ).href; //タイトルコール/ソロ用
		//const urlTitleU = new gURL( id2vo("d"), this.urlIcon ).href; //タイトルコール/ユニット用
		//const urlNameX = new gURL( id2vo("1"), this.urlIcon ).href;  //名前(体言止め)
		//const urlNameD = new gURL( id2vo("2"), this.urlIcon ).href;  //名前＋です

		try {
			this[tIdol.pNmADtitle1] = await asyncGetAudioData(urlTitleS);
			if( ! this[tIdol.pNmADtitle1] ){ throw "if there is HTTP:404 then never mind."; }
			//引き続き、残る要素を読み込む。並列処理テクを使う。
			//1. await抜きでasync関数を呼び出すことでPromiseを生成(実行開始)。
			const prmIcon = promiseGetImage(this.urlIcon);
			//2. そのPromiseインスタンスをawaitする。Promise群の中で一番遅いものの時間で処理できる。
			this[tIdol.pNmIMGicon] = await prmIcon;
		} catch (e) {
			//読み込めなかったらこのブロックに来てからfinallyブロックへ
			console.log(e);
		} finally {
			_fnFinally( this );
		}
	}

	//class tIdol のインスタンスを取り出す。さもなくば return null
	standIdol(){
		return (
			this[tIdol.pNmADtitle1] && this[tIdol.pNmIMGicon]
		)? new tIdol(this) : null;
	}
}


// ++非同期関数++ リソースの読み出し
async function asyncFetchResources() {

	// ++非同期関数++ 問い合わせてレスポンスのJSONをオブジェクトに変換して返す。
	const asyncFetchAndStrip = async ( url ) => {
		const resReq = await fetch( url.href );
		return (await resReq.json())["result"];
	};

	let arrslt = await asyncFetchAndStrip(urlFirstRequest);
	//最初の結果を利用して次に呼び出すURLを構築
	let strCharIds = "";
	for( const s of arrslt ){ strCharIds += (strCharIds.length>0 ? `,${s["chara_id"]}` : s["chara_id"]); }
	let secondRequestURL = new gURL(pathCharDetail+strCharIds, urlFirstRequest);
	arrslt = await asyncFetchAndStrip(secondRequestURL);

	for( let objrslt of arrslt ){
		if( ! objrslt["voice"] ) continue;
		//専用のローダーに返答オブジェクトを渡せば良いようにしてあります
		let idldr = new tIdolLoader(objrslt);
		arIdolLoaders.push( idldr );
		idldr.asyncLoad( cbIdolLoader );
	}
	console.log(`(asyncFetchResources) 全 ${arrslt.length} 人、CV設定あり ${arIdolLoaders.length} 人`);
}

//callback of tIdolLoaer
function cbIdolLoader( _objILr ){

	//インスタンスを取り出せれば配列に登録。
	let objIdol = _objILr.standIdol();
	if( objIdol ){ arIdolDatas.push( objIdol ); }

	//処理が終わったので、配列から取り除く
	const idxILs = arIdolLoaders.indexOf( _objILr );
	if( idxILs < 0 ) throw new Error("cbIdolLoader() / unknown tIdolLoader object found");
	arIdolLoaders.splice( idxILs,　1　);

	//ここに表示リフレッシュ処理
	console.log(`(cbIdolLoader) 結果=${!!objIdol} 成功x${arIdolDatas.length} 残件x${arIdolLoaders.length}`);

	if( arIdolLoaders.length == 0 ){
		//全部終わったー　とりあえずID順に整列
		arIdolDatas.sort( (fore,back) => fore.cid - back.cid );
		for( objIdol of arIdolDatas ){
			//グリッドシステムに表示ブロックを入れ込む。
			let p = NEW_TAG("div");
			p.className = "imascg-"+objIdol.type;
			p.appendChild( objIdol[tIdol.pNmIMGicon] );
//			p.appendChild( NEW_TAG("br") );
/*
			let b = NEW_TAG("button");
			b.textContent = tIdol.pNmADtitle1;
			b.idol = objIdol;
			b.onclick = ()=>{ this.idol.playAudio( tIdol.pNmADtitle1, gAudioCtx.destination, gAudioCtx.currentTime ); };
			p.appendChild( b );
			p.appendChild( NEW_TAG("br") );
*/
			divFukol.insertBefore(p, divFukol.firstChild);
		}
	}
}

//ページ読み込み時処理
window.addEventListener("load",()=>{
	divLog = NEW_TAG("div");
	document.body.appendChild(divLog);
	divFukol = NEW_TAG("div");
	divFukol.className = "fukol-grid";
	divLog.appendChild(divFukol);
	asyncFetchResources();
});

</script>
</body>
</html>
